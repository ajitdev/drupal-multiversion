<?php

use Drupal\Core\Database\Database;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Url;
use Drupal\migrate\MigrateExecutable;
use Drupal\migrate\MigrateMessage;
use Drupal\multiversion\Entity\WorkspaceInterface;
use Drupal\views\Plugin\views\query\QueryPluginBase;
use Drupal\views\ViewExecutable;

/**
 * Implements hook_entity_type_alter().
 *
 * @param \Drupal\Core\Entity\EntityTypeInterface[] $entity_types
 */
function multiversion_entity_type_alter(array &$entity_types) {
  /** @var \Drupal\multiversion\MultiversionManagerInterface $manager */
  $manager = \Drupal::service('multiversion.manager');

  foreach ($entity_types as $entity_type) {
    if ($manager->isSupportedEntityType($entity_type)) {
      // Make all content entity types revisionable.
      if (!$entity_type->isRevisionable()) {
        // We only need to set the revision key to make an entity type
        // revisionable. The table names will be handled by the storage class.
        // @see \Drupal\Core\Entity\Sql\SqlContentEntityStorage::initTableLayout
        $keys = $entity_type->getKeys();
        $keys['revision'] = 'revision_id';
        $entity_type->set('entity_keys', $keys);
      }
      $namespace = 'Drupal\multiversion\Entity\Storage\Sql';
      switch ($entity_type->id()) {
        case 'node':
          $entity_type->setStorageClass($namespace . '\NodeStorage');
          break;
        case 'taxonomy_term':
          $entity_type->setStorageClass($namespace . '\TermStorage');
          break;
        case 'comment':
          $entity_type->setStorageClass($namespace . '\CommentStorage');
          break;
        case 'menu_link_content':
          $entity_type->setStorageClass($namespace . '\MenuLinkContentStorage');
          break;
        case 'user':
          $entity_type->setStorageClass($namespace . '\UserStorage');
          break;
        default:
          $entity_type->setStorageClass($namespace . '\ContentEntityStorage');
      }
    }
  }
}

/**
 * Implements hook_entity_base_field_info().
 *
 * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
 * @return \Drupal\Core\Field\BaseFieldDefinition[]
 */
function multiversion_entity_base_field_info(EntityTypeInterface $entity_type) {
  /** @var \Drupal\multiversion\MultiversionManagerInterface $manager */
  $manager = \Drupal::service('multiversion.manager');

  if ($manager->isSupportedEntityType($entity_type)) {
    $fields = array();

    // This will essentially overwrite the revision field definition but also
    // ensure that entity types that we enabled revisions for get a revision
    // field definition of a type that we expect.
    $fields[$entity_type->getKey('revision')] = BaseFieldDefinition::create('integer')
      ->setLabel(t('Revision ID'))
      ->setDescription(t('The local revision ID of the entity.'))
      ->setReadOnly(TRUE)
      ->setSetting('unsigned', TRUE);

    // @todo Make this not revisionable, currently it's not possible.
    // @see https://www.drupal.org/node/2362433
    $fields['workspace'] = BaseFieldDefinition::create('workspace_reference')
      ->setLabel('Workspace reference')
      ->setDescription('The workspace this entity belongs to.')
      ->setSetting('target_type', 'workspace')
      ->setRevisionable(TRUE)
      ->setTranslatable(FALSE)
      ->setCardinality(1)
      ->setReadOnly(TRUE);

    $fields['_deleted'] = BaseFieldDefinition::create('boolean')
      ->setLabel('Deleted flag')
      ->setDescription('Indicates if the entity is flagged as deleted or not.')
      ->setRevisionable(TRUE)
      ->setTranslatable(TRUE)
      ->setDefaultValue(FALSE)
      ->setCardinality(1);

    $fields['_rev'] = BaseFieldDefinition::create('revision_token')
      ->setLabel('Revision token')
      ->setDescription('The token for this entity revision.')
      ->setRevisionable(TRUE)
      ->setTranslatable(TRUE)
      ->setCardinality(1)
      ->setReadOnly(TRUE);

    return $fields;
  }
}

/**
 * Implements hook_entity_base_field_info_alter().
 *
 * @param array $fields
 * @param \Drupal\Core\Entity\EntityTypeInterface $entity_type
 */
function multiversion_entity_base_field_info_alter(&$fields, EntityTypeInterface $entity_type) {
  /** @var \Drupal\multiversion\MultiversionManagerInterface $manager */
  $manager = \Drupal::service('multiversion.manager');
  $need_update = array('taxonomy_term', 'comment', 'menu_link_content');
  if ($manager->isSupportedEntityType($entity_type) && in_array($entity_type->id(), $need_update)) {
    $exclude_fields = array();
    $exclude = array('id', 'uuid', 'revision_id', 'language', 'bundle');
    if ($entity_type->id() == 'taxonomy_term') {
      $exclude_fields = array_merge($exclude, array('tid', 'vid'));
    }
    if ($entity_type->id() == 'comment') {
      $exclude_fields = array_merge($exclude, array('cid','comment_type'));
    }
    if ($entity_type->id() == 'menu_link_content') {
      $exclude_fields = array_merge($exclude, array());
    }
    foreach ($fields as $key => $field) {
      if (!in_array($key, $exclude_fields)) {
        $field->setRevisionable(TRUE);
      }
    }
  }
}

/**
 * Implements hook_views_query_alter().
 *
 * @param \Drupal\views\ViewExecutable $view
 *   The view object about to be processed.
 * @param QueryPluginBase $query
 *   The query plugin object for the query.
 */
function multiversion_views_query_alter(ViewExecutable $view, QueryPluginBase $query) {
  // Add a new filter for default core views, it will filter deleted content.
  $views_machine_names = array(
    'content',
    'frontpage',
    'comments_recent',
    'content_recent',
    'taxonomy_term',
    'glossary',
    'archive',
    'user_admin_people',
  );
  $id = $view->storage->id();
  if (in_array($id, $views_machine_names)) {
    $base_table = $view->storage->get('base_table');
    $view->query->where[1]['conditions'][] = array(
      'field' => $base_table . '._deleted',
      'value' => FALSE,
      'operator' => '='
    );
    // We shouldn't filter user content type when creating a new node because
    // we need the author info for this.
    if (strpos(\Drupal::url('<current>'), 'node/add/'
      && $base_table == 'users_field_data') !== TRUE) {
      $view->query->where[1]['conditions'][] = array(
        'field' => $base_table . '.workspace',
        'value' => multiversion_get_active_workspace_id(),
        'operator' => '='
      );
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function multiversion_entity_insert(EntityInterface $entity) {
  $manager = \Drupal::service('multiversion.manager');
  if ($entity->uuid() && $manager->isSupportedEntityType($entity->getEntityType())) {
    \Drupal::service('entity.index.sequence')->add($entity);
    \Drupal::service('entity.index.id')->add($entity);
    \Drupal::service('entity.index.uuid')->add($entity);
    \Drupal::service('entity.index.rev')->add($entity);
  }
}

/**
 * Implements hook_entity_update().
 */
function multiversion_entity_update(EntityInterface $entity) {
  multiversion_entity_insert($entity);
}

/**
 * Implements hook_modules_installed().
 */
function multiversion_modules_installed($modules) {
  if (in_array('multiversion', $modules)) {
    // Apply updates. We need to run this before user migration.
    \Drupal::service('entity.definition_update_manager')->applyUpdates();

    // Install required modules for migration.
    $dependencies = array('migrate', 'migrate_drupal', 'file');
    foreach ($dependencies as $module) {
      if (\Drupal::moduleHandler()->moduleExists($module)) {
        unset($dependencies['$module']);
      }
    }
    \Drupal::service('module_installer')->install($dependencies, TRUE);

    $batch = array(
      'title' => t('Change user storage class and migrate content to the new storage.'),
      'operations' => array(
        array('_multiversion_make_user_entity_type_multiversionable', array()),
      ),
      'init_message' => t('Executing migration.'),
      'finished' => '_multiversion_migration_finished',
    );
    batch_set($batch);

    // This is necessary when running updates in a batch in drush.
    if (function_exists('drush_backend_batch_process')) {
      $batch =& batch_get();
      $batch['progressive'] = FALSE;
      drush_backend_batch_process();
    }
    else {
      // This is necessary when running tests from Drupal UI.
      $system_path = \Drupal::service('path.current')->getPath();
      if ($system_path == '/batch') {
        $batch =& batch_get();
        $batch['progressive'] = FALSE;
        batch_process();
      }
    }
  }
}

/**
 * Load a deleted entity.
 *
 * @param string $entity_type
 * @param integer $id
 * @param boolean $reset
 */
function entity_load_deleted($entity_type, $id, $reset = FALSE) {
  $controller = \Drupal::entityManager()->getStorage($entity_type);
  if ($reset) {
    $controller->resetCache(array($id));
  }
  return $controller->loadDeleted($id);
}

/**
 * Load multiple deleted entities.
 *
 * @param string $entity_type
 * @param array $ids
 * @param boolean $reset
 */
function entity_load_multiple_deleted($entity_type, $ids, $reset = FALSE) {
  $controller = \Drupal::entityManager()->getStorage($entity_type);
  if ($reset) {
    $controller->resetCache($ids);
  }
  return $controller->loadMultipleDeleted($ids);
}

/**
 * Callback for getting the active workspace ID.
 */
function multiversion_get_active_workspace_id() {
  return \Drupal::service('multiversion.manager')->getActiveWorkspaceId();
}

/**
 * URI callback for the workspace entity type.
 */
function multiversion_workspace_uri(WorkspaceInterface $entity) {
  return $entity->id();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function multiversion_form_node_type_edit_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  // Users don't have the option to disable revisions when using Multiversion.
  // @todo: See if there's a way to just disable this particular option.
  unset($form['workflow']['options']['#options']['revision']);
}

/**
 * Implements hook_form_alter().
 */
function multiversion_form_alter(&$form, \Drupal\Core\Form\FormStateInterface $form_state, $form_id) {
  if (isset($form['revision']['#group']) && $form['revision']['#group'] == 'revision_information') {
    // Users don't have the option to disable revisions when using Multiversion.
    $form['revision']['#default_value'] = TRUE;
    $form['revision']['#disabled'] = TRUE;
  }
}

/**
 * Makes user content type multiversionable.
 *
 * Delete all users and applies updates to make user entity type multiversionable.
 */
function _multiversion_make_user_entity_type_multiversionable() {
  // Adds database connection information for migration.
  $connection_info = Database::getConnectionInfo('default');
  foreach ($connection_info as $target => $value) {
    $connection_info[$target]['prefix'] = array(
      'default' => $value['prefix']['default'],
    );
  }
  Database::addConnectionInfo('migrate', 'default', $connection_info['default']);

  $context['message'] = t('Migrate users from database to json file.');
  $migration = entity_load('migration', 'migrate_users_from_drupal8_to_json');
  $message = new MigrateMessage();
  $executable = new MigrateExecutable($migration, $message);
  $executable->import();

  $context['message'] = t('Update the user entity type.');
  $entity_manager = \Drupal::entityManager();
  $entity_type = $entity_manager->getDefinition('user');
  $entity_type_id = $entity_type->id();
  $uids = db_select('users_field_data', 'u')
    ->fields('u', array('uid'))
    ->execute()
    ->fetchCol('uid');
  $entities = entity_load_multiple('user', array_values($uids));
  // Delete all users from the database.
  $entity_manager->getStorage($entity_type_id)->delete($entities);

  // This configuration is used when checking supported entity types. After user
  // migration to the json file we set 'user' as a supported entity type.
  \Drupal::state()->set('multiversion_user_migration_to_json_done', TRUE);

  // Apply updates.
  if (!$entity_manager->getStorage($entity_type_id)->hasData()) {
    \Drupal::service('entity.definition_update_manager')->applyUpdates();
  }

  $context['message'] = t('Migrate users from json file to database.');
  $migration = entity_load('migration', 'migrate_users_from_json_to_drupal8');
  $executable = new MigrateExecutable($migration, $message);
  $executable->import();
}

/**
 * Implements callback_batch_finished().
 *
 * @param bool $success
 *   A boolean indicating whether the re-build process has completed.
 * @param array $results
 *   An array of results information.
 * @param array $operations
 *   An array of function calls (not used in this function).
 */
function _multiversion_migration_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('Successfully migrated users to the new storage.'));
  }
  else {
    drupal_set_message(t('User migration to the new storage failed.'), 'error');
  }
}
